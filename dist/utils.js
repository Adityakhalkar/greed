"use strict";(this.webpackChunkGreed=this.webpackChunkGreed||[]).push([[738],{219:(e,t,s)=>{s.d(t,{A:()=>a});var r=s(123);class i extends r.A{constructor(e={}){super(),this.config={strictMode:!1!==e.strictMode,allowEval:!0===e.allowEval,allowFileSystem:!0===e.allowFileSystem,allowNetwork:!0===e.allowNetwork,allowSubprocess:!0===e.allowSubprocess,maxCodeLength:e.maxCodeLength||1e5,maxTensorSize:e.maxTensorSize||1e8,maxTensorCount:e.maxTensorCount||100,maxStringLength:e.maxStringLength||1e4,maxMemoryMB:e.maxMemoryMB||1024,maxExecutionTimeMs:e.maxExecutionTimeMs||3e4,allowedPackages:new Set(e.allowedPackages||["numpy","math","random","json","datetime","collections","itertools","functools","operator","re"]),customDangerousPatterns:e.customDangerousPatterns||[],customAllowedPatterns:e.customAllowedPatterns||[],...e},this.dangerousPatterns=this._initializeDangerousPatterns(),this.suspiciousPatterns=this._initializeSuspiciousPatterns(),this.fileSystemPatterns=this._initializeFileSystemPatterns(),this.networkPatterns=this._initializeNetworkPatterns(),this.stats={totalValidations:0,blockedOperations:0,warningsIssued:0,lastValidation:null,threatCategories:{}}}validatePythonCode(e,t={}){const s=performance.now();this.stats.totalValidations++;try{this.emit("validation:start",{codeLength:e.length,strict:this.config.strictMode}),this._validateCodeInput(e);const r=this._analyzeSecurityThreats(e),i=this._assessRiskLevel(r),o=this._enforceSecurityPolicy(e,r,i,t);this._updateValidationStats(r,i,o);const a=performance.now()-s;return this.emit("validation:complete",{threats:r.length,riskLevel:i,allowed:o.allowed,validationTime:a}),o}catch(t){throw this.emit("validation:error",{error:t,codePreview:e.substring(0,100)}),t}}validateTensorData(e,t={}){const s=Array.isArray(e)?e:[e];this.emit("tensor:validation:start",{tensorCount:s.length});try{if(s.length>this.config.maxTensorCount)throw new o(`Too many tensors: ${s.length} > ${this.config.maxTensorCount}`);let e=0,t=0;for(let r=0;r<s.length;r++){const i=s[r];if(!this._isValidTensorType(i))throw new o(`Invalid tensor type at index ${r}: ${typeof i}`);const a=this._getTensorElementCount(i);if(a>this.config.maxTensorSize)throw new o(`Tensor too large at index ${r}: ${a} > ${this.config.maxTensorSize}`);const n=this._estimateTensorMemoryMB(i);t+=n,e+=a,this.emit("tensor:validated",{index:r,elements:a,memoryMB:Math.round(100*n)/100})}if(t>this.config.maxMemoryMB)throw new o(`Total tensor memory too large: ${Math.round(t)}MB > ${this.config.maxMemoryMB}MB`);return this.emit("tensor:validation:complete",{tensorCount:s.length,totalElements:e,totalMemoryMB:Math.round(100*t)/100}),{valid:!0,tensorCount:s.length,totalElements:e,totalMemoryMB:t,warnings:[]}}catch(e){throw this.emit("tensor:validation:error",{error:e}),e}}validateOperation(e,t,s={}){this.emit("operation:validation:start",{operation:e});try{if(!e||"string"!=typeof e)throw new o("Operation must be a non-empty string");if(e.length>100)throw new o(`Operation name too long: ${e.length} > 100`);if(["eval","exec","compile","__import__","subprocess"].some(t=>e.toLowerCase().includes(t)))throw new o(`Dangerous operation detected: ${e}`);const r=this._validateOperationParams(t),i=this._validateOperationOptions(s);return this.emit("operation:validation:complete",{operation:e,paramCount:Object.keys(r).length}),{valid:!0,operation:e,params:r,options:i}}catch(t){throw this.emit("operation:validation:error",{operation:e,error:t}),t}}validateURL(e,t={}){const{allowedDomains:s=[],blockedDomains:r=[],requireHTTPS:i=!0}=t;try{const t=new URL(e);if(i&&"https:"!==t.protocol)throw new o(`HTTPS required for URL: ${e}`);if(r.includes(t.hostname))throw new o(`Blocked domain: ${t.hostname}`);if(s.length>0&&!s.includes(t.hostname))throw new o(`Domain not in allowlist: ${t.hostname}`);if([/localhost/i,/127\.0\.0\.1/,/0\.0\.0\.0/,/\[::\]/,/internal/i,/private/i,/admin/i,/\.local$/i].some(t=>t.test(e)))throw new o(`Suspicious URL pattern detected: ${e}`);return{valid:!0,url:t.href,domain:t.hostname}}catch(t){if(t instanceof o)throw t;throw new o(`Invalid URL: ${e} - ${t.message}`)}}getStats(){return{...this.stats,config:{strictMode:this.config.strictMode,maxTensorSize:this.config.maxTensorSize,maxMemoryMB:this.config.maxMemoryMB,allowedPackages:Array.from(this.config.allowedPackages)}}}updateConfig(e){const t={...this.config};this.config={...this.config,...e},e.allowedPackages&&(this.config.allowedPackages=new Set(e.allowedPackages)),this.emit("config:updated",{oldConfig:t,newConfig:this.config})}resetStats(){this.stats={totalValidations:0,blockedOperations:0,warningsIssued:0,lastValidation:null,threatCategories:{}},this.emit("stats:reset")}_validateCodeInput(e){if("string"!=typeof e)throw new o("Code must be a string");if(0===e.length)throw new o("Code cannot be empty");if(e.length>this.config.maxCodeLength)throw new o(`Code too long: ${e.length} > ${this.config.maxCodeLength}`);if(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/.test(e))throw new o("Code contains invalid control characters")}_analyzeSecurityThreats(e){const t=[];for(const[s,r]of Object.entries(this.dangerousPatterns))for(const i of r){const r=e.match(i.regex);r&&t.push({category:s,type:"dangerous",pattern:i.name,severity:i.severity,matches:r.length,description:i.description,firstMatch:r[0]})}for(const[s,r]of Object.entries(this.suspiciousPatterns))for(const i of r){const r=e.match(i.regex);r&&t.push({category:s,type:"suspicious",pattern:i.name,severity:i.severity,matches:r.length,description:i.description,firstMatch:r[0]})}if(!this.config.allowFileSystem)for(const s of this.fileSystemPatterns){const r=e.match(s.regex);r&&t.push({category:"filesystem",type:"blocked",pattern:s.name,severity:"high",matches:r.length,description:"File system access not allowed",firstMatch:r[0]})}if(!this.config.allowNetwork)for(const s of this.networkPatterns){const r=e.match(s.regex);r&&t.push({category:"network",type:"blocked",pattern:s.name,severity:"high",matches:r.length,description:"Network access not allowed",firstMatch:r[0]})}return t}_assessRiskLevel(e){if(0===e.length)return"low";const t=e.filter(e=>"critical"===e.severity).length,s=e.filter(e=>"high"===e.severity).length,r=e.filter(e=>"medium"===e.severity).length;return t>0||s>2?"critical":s>0||r>3?"high":r>0?"medium":"low"}_enforceSecurityPolicy(e,t,s,r={}){const{allowWarnings:i=!1,bypassValidation:a=!1}=r;if(a&&!this.config.strictMode)return this.emit("policy:bypassed",{riskLevel:s,threats:t.length}),{allowed:!0,bypassed:!0,riskLevel:s,threats:t,warnings:["Security validation was bypassed"]};if("critical"===s||"high"===s&&this.config.strictMode)throw this.stats.blockedOperations++,this.emit("policy:blocked",{riskLevel:s,threats:t.length}),new o(`Security policy violation: ${s} risk detected with ${t.length} threats`);if("medium"===s){if(i)return this.stats.warningsIssued++,this.emit("policy:warning",{riskLevel:s,threats:t.length}),{allowed:!0,riskLevel:s,threats:t,warnings:t.map(e=>`${e.category}: ${e.description}`)};if(this.config.strictMode)throw this.stats.blockedOperations++,new o(`Security policy violation: ${s} risk detected (strict mode)`)}return{allowed:!0,riskLevel:s,threats:t,warnings:"low"===s?[]:t.map(e=>`${e.category}: ${e.description}`)}}_isValidTensorType(e){return ArrayBuffer.isView(e)||e instanceof ArrayBuffer||Array.isArray(e)||e&&"object"==typeof e&&e.constructor&&e.constructor.name.includes("Array")}_getTensorElementCount(e){return ArrayBuffer.isView(e)?e.length:e instanceof ArrayBuffer?e.byteLength/4:Array.isArray(e)?e.length:0}_estimateTensorMemoryMB(e){return this._getTensorElementCount(e)*(ArrayBuffer.isView(e)?e.BYTES_PER_ELEMENT:4)/1048576}_validateOperationParams(e){const t={};for(const[s,r]of Object.entries(e||{})){if("string"!=typeof s||s.length>100)throw new o(`Invalid parameter key: ${s}`);if("string"==typeof r&&r.length>this.config.maxStringLength)throw new o(`Parameter value too long: ${s}`);t[s]=r}return t}_validateOperationOptions(e){const t={},s=["timeout","strategy","workgroupSize","dataType","precision","optimization","caching","parallel"];for(const[r,i]of Object.entries(e||{}))s.includes(r)?t[r]=i:this.emit("option:unknown",{key:r,value:i});return t}_updateValidationStats(e,t,s){this.stats.lastValidation={timestamp:Date.now(),threats:e.length,riskLevel:t,allowed:s.allowed};for(const t of e)this.stats.threatCategories[t.category]||(this.stats.threatCategories[t.category]=0),this.stats.threatCategories[t.category]++}_initializeDangerousPatterns(){return{codeExecution:[{name:"eval",regex:/\beval\s*\(/g,severity:"critical",description:"Dynamic code execution with eval()"},{name:"exec",regex:/\bexec\s*\(/g,severity:"critical",description:"Dynamic code execution with exec()"},{name:"compile",regex:/\bcompile\s*\(/g,severity:"high",description:"Code compilation detected"}],imports:[{name:"dynamic_import",regex:/\b__import__\s*\(/g,severity:"high",description:"Dynamic import detected"},{name:"importlib",regex:/\bimportlib\./g,severity:"medium",description:"Import library usage"}],subprocess:[{name:"subprocess",regex:/\bsubprocess\./g,severity:"critical",description:"Subprocess execution"},{name:"os_system",regex:/\bos\.system\s*\(/g,severity:"critical",description:"OS system command execution"},{name:"popen",regex:/\bos\.popen\s*\(/g,severity:"critical",description:"Process execution with popen"}]}}_initializeSuspiciousPatterns(){return{reflection:[{name:"getattr",regex:/\bgetattr\s*\(/g,severity:"medium",description:"Attribute access via getattr"},{name:"setattr",regex:/\bsetattr\s*\(/g,severity:"medium",description:"Attribute modification via setattr"},{name:"hasattr",regex:/\bhasattr\s*\(/g,severity:"low",description:"Attribute existence check"}],globals:[{name:"globals",regex:/\bglobals\s*\(\s*\)/g,severity:"medium",description:"Access to global namespace"},{name:"locals",regex:/\blocals\s*\(\s*\)/g,severity:"medium",description:"Access to local namespace"},{name:"vars",regex:/\bvars\s*\(/g,severity:"low",description:"Variable inspection"}]}}_initializeFileSystemPatterns(){return[{name:"open",regex:/\bopen\s*\(/g,severity:"high",description:"File opening operation"},{name:"file",regex:/\bfile\s*\(/g,severity:"high",description:"File object creation"},{name:"pathlib",regex:/\bpathlib\./g,severity:"medium",description:"Path manipulation"}]}_initializeNetworkPatterns(){return[{name:"urllib",regex:/\burllib\./g,severity:"high",description:"URL library usage"},{name:"requests",regex:/\brequests\./g,severity:"high",description:"HTTP requests library"},{name:"socket",regex:/\bsocket\./g,severity:"high",description:"Socket networking"}]}}class o extends Error{constructor(e,t="security",s="high"){super(e),this.name="SecurityError",this.category=t,this.severity=s,this.timestamp=(new Date).toISOString()}}const a=i},626:(e,t,s)=>{s.d(t,{A:()=>i});class r{constructor(e={}){this.config={level:e.level||"warn",enableConsole:!1!==e.enableConsole,prefix:e.prefix||"Greed",timestamp:!1!==e.timestamp,...e},this.levels={error:0,warn:1,info:2,debug:3},this.currentLevelPriority=this.levels[this.config.level]||1}_shouldLog(e){return this.levels[e]<=this.currentLevelPriority}_formatMessage(e,t,...s){return{formatted:`${[this.config.timestamp?(new Date).toISOString():"",this.config.prefix?`[${this.config.prefix}]`:"",`[${e.toUpperCase()}]`].filter(Boolean).join(" ")} ${t}`,args:s}}error(e,...t){if(this._shouldLog("error")&&this.config.enableConsole){const{formatted:s,args:r}=this._formatMessage("error",e,...t);console.error(s,...r)}}warn(e,...t){if(this._shouldLog("warn")&&this.config.enableConsole){const{formatted:s,args:r}=this._formatMessage("warn",e,...t);console.warn(s,...r)}}info(e,...t){if(this._shouldLog("info")&&this.config.enableConsole){const{formatted:s,args:r}=this._formatMessage("info",e,...t);console.log(s,...r)}}debug(e,...t){if(this._shouldLog("debug")&&this.config.enableConsole){const{formatted:s,args:r}=this._formatMessage("debug",e,...t);console.log(s,...r)}}setLevel(e){e in this.levels&&(this.config.level=e,this.currentLevelPriority=this.levels[e])}child(e){return new r({...this.config,prefix:`${this.config.prefix}:${e}`})}}const i=new r},683:(e,t,s)=>{s.d(t,{A:()=>a});var r=s(123),i=s(626);class o extends r.A{constructor(e={}){super(),this.config={maxMemoryMB:e.maxMemoryMB||1024,gcThreshold:e.gcThreshold||.8,checkInterval:e.checkInterval||5e3,enableAutoGC:!1!==e.enableAutoGC,...e},this.resources=new Map,this.bufferPool=new Map,this.activeBuffers=new Set,this.memoryUsage=0,this.peakMemoryUsage=0,this.gcCount=0,this.registry=null,this.cleanupTasks=new Set,this.monitoringInterval=null,this._initializeFinalizationRegistry(),this.config.enableAutoGC&&this._startMemoryMonitoring()}register(e,t,s={}){const{size:r=0,type:i="generic",priority:o="normal",autoRelease:a=!0}=s,n=this._generateId(),c={id:n,resource:e,cleanup:t,size:r,type:i,priority:o,autoRelease:a,createdAt:Date.now(),lastAccessed:Date.now()};return this.resources.set(n,c),this.memoryUsage+=r,this.peakMemoryUsage=Math.max(this.peakMemoryUsage,this.memoryUsage),this.registry&&a&&this.registry.register(e,{id:n,cleanup:t},e),this.emit("resource:registered",{id:n,type:i,size:r}),this._shouldRunGC()&&this._scheduleGC(),n}async unregister(e){const t=this.resources.get(e);if(!t)return!1;try{return await this._cleanupResource(t),this.resources.delete(e),this.memoryUsage-=t.size,this.emit("resource:unregistered",{id:e,type:t.type,size:t.size}),!0}catch(t){return this.emit("cleanup:error",{id:e,error:t}),!1}}allocateBuffer(e,t,s=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const r=`${t}-${s}`,i=this.bufferPool.get(r);let o;i&&i.length>0?(o=i.pop(),this.emit("buffer:reused",{size:t,usage:s})):(o=e.createBuffer({size:t,usage:s}),this.emit("buffer:created",{size:t,usage:s})),this.activeBuffers.add(o);const a=this.register(o,()=>this._cleanupBuffer(o),{size:t,type:"webgpu-buffer",priority:"high"});return o._greedId=a,o}releaseBuffer(e,t={}){const{destroy:s=!1,poolMaxSize:r=20}=t;if(!this.activeBuffers.has(e))return!1;if(this.activeBuffers.delete(e),e._greedId&&this.unregister(e._greedId),s)return e.destroy(),this.emit("buffer:destroyed",{buffer:e}),!0;const i=`${e.size}-${e.usage}`;this.bufferPool.has(i)||this.bufferPool.set(i,[]);const o=this.bufferPool.get(i);return o.length<r?(o.push(e),this.emit("buffer:pooled",{buffer:e,poolSize:o.length})):(e.destroy(),this.emit("buffer:destroyed",{buffer:e,reason:"pool-full"})),!0}async forceGC(e={}){const{aggressive:t=!1,targetReduction:s=.3,maxAge:r=3e5}=e;this.gcCount++;const i=performance.now(),o=this.memoryUsage;this.emit("gc:start",{aggressive:t,targetReduction:s});try{let e=0;const a=Date.now(),n=Array.from(this.resources.entries()).sort(([,e],[,t])=>{if(e.priority!==t.priority){const s={low:0,normal:1,high:2};return s[e.priority]-s[t.priority]}return a-e.lastAccessed-(a-t.lastAccessed)});for(const[i,c]of n){const n=a-c.lastAccessed;if((t||n>r||"low"===c.priority&&this._shouldRunGC())&&c.autoRelease&&await this.unregister(i)&&e++,(o-this.memoryUsage)/o>=s)break}window.gc&&t&&window.gc();const c=performance.now()-i,l=o-this.memoryUsage;return this.emit("gc:complete",{cleaned:e,duration:c,memoryReduction:l,newMemoryUsage:this.memoryUsage}),{cleaned:e,memoryReduction:l,duration:c}}catch(e){throw this.emit("gc:error",{error:e}),e}}getStats(){return{memoryUsage:this.memoryUsage,memoryUsageMB:Math.round(this.memoryUsage/1048576*100)/100,maxMemoryMB:this.config.maxMemoryMB,peakMemoryUsage:this.peakMemoryUsage,peakMemoryUsageMB:Math.round(this.peakMemoryUsage/1048576*100)/100,memoryUtilization:this.memoryUsage/(1024*this.config.maxMemoryMB*1024),resourceCount:this.resources.size,activeBuffers:this.activeBuffers.size,bufferPools:this.bufferPool.size,gcCount:this.gcCount,resourceTypes:this._getResourceTypeStats()}}async cleanup(){this.emit("cleanup:start");try{this.monitoringInterval&&(clearInterval(this.monitoringInterval),this.monitoringInterval=null);const e=Array.from(this.resources.keys());for(const t of e)await this.unregister(t);for(const e of this.bufferPool.values())for(const t of e)t.destroy();this.bufferPool.clear();for(const e of this.activeBuffers)e.destroy();this.activeBuffers.clear(),this.memoryUsage=0,this.emit("cleanup:complete")}catch(e){throw this.emit("cleanup:error",{error:e}),e}}_initializeFinalizationRegistry(){"undefined"!=typeof FinalizationRegistry&&(this.registry=new FinalizationRegistry(({id:e,cleanup:t})=>{try{if(t(),this.resources.has(e)){const t=this.resources.get(e);this.resources.delete(e),this.memoryUsage-=t.size,this.emit("resource:finalized",{id:e})}}catch(t){this.emit("finalization:error",{id:e,error:t})}}))}_startMemoryMonitoring(){this.monitoringInterval=setInterval(()=>{this._shouldRunGC()&&this.forceGC({aggressive:!1})},this.config.checkInterval)}_shouldRunGC(){const e=1024*this.config.maxMemoryMB*1024;return this.memoryUsage>e*this.config.gcThreshold}_scheduleGC(){setTimeout(()=>this.forceGC(),0)}async _cleanupResource(e){try{"function"==typeof e.cleanup&&await e.cleanup()}catch(t){throw new Error(`Failed to cleanup resource ${e.id}: ${t.message}`)}}_cleanupBuffer(e){return new Promise(t=>{try{e&&"function"==typeof e.destroy&&e.destroy(),t()}catch(s){i.A.warn("Buffer cleanup error:",{bufferId:e._greedId,error:s.message,stack:s.stack}),t()}})}_generateId(){return`mem_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}_getResourceTypeStats(){const e={};for(const t of this.resources.values())e[t.type]||(e[t.type]={count:0,totalSize:0}),e[t.type].count++,e[t.type].totalSize+=t.size;return e}}const a=o},838:(e,t,s)=>{s.d(t,{default:()=>o});var r=s(626),i=s(683);const o=class{constructor(e={}){this.options={format:e.format||"json",compression:e.compression||!1,includeMetadata:!1!==e.includeMetadata,validateOnLoad:!1!==e.validateOnLoad,...e},this.memoryManager=new i.A,this.version="1.0.0"}async save(e,t=null,s={}){try{r.A.info("Starting model serialization",{path:t,options:s});const i=await this._extractStateDict(e),o={version:this.version,timestamp:Date.now(),model_state_dict:i,metadata:this.options.includeMetadata?this._extractMetadata(e):null,greed_version:"2.0.0",pytorch_compatible:!0};let a;return s.epoch&&(o.epoch=s.epoch),s.loss&&(o.loss=s.loss),s.optimizer_state&&(o.optimizer_state_dict=await this._extractOptimizerState(s.optimizer_state)),a="binary"===this.options.format?await this._serializeToBinary(o):JSON.stringify(o,null,2),t?(await this._saveToFile(a,t),r.A.info("Model saved successfully",{path:t,size:a.length}),t):(r.A.info("Model serialized to memory",{size:a.length}),a)}catch(e){throw r.A.error("Model save failed",{error:e.message,stack:e.stack}),new Error(`Failed to save model: ${e.message}`)}}async load(e,t=null,s={}){try{let i;r.A.info("Starting model deserialization",{hasModel:!!t,options:s}),i="string"==typeof e?e.startsWith("{")||e.startsWith("[")?JSON.parse(e):await this._loadFromFile(e):e,this.options.validateOnLoad&&this._validateSerializedData(i);const o=i.model_state_dict;t&&(await this._loadStateDict(t,o,s),r.A.info("Model state loaded successfully",{parameters:Object.keys(o).length}));const a={state_dict:o,metadata:i.metadata,epoch:i.epoch,loss:i.loss,optimizer_state_dict:i.optimizer_state_dict,version:i.version,timestamp:i.timestamp,pytorch_compatible:i.pytorch_compatible};return r.A.info("Model loaded successfully",{version:a.version,parameters:Object.keys(o).length}),a}catch(e){throw r.A.error("Model load failed",{error:e.message,stack:e.stack}),new Error(`Failed to load model: ${e.message}`)}}async saveCheckpoint(e,t){const{model:s,optimizer:r,epoch:i,loss:o,...a}=e,n={epoch:i,loss:o,...a};return s&&(n.model=s),r&&(n.optimizer_state=r),this.save(s,t,n)}async loadCheckpoint(e,t=null,s=null){const r=await this.load(e,t);return s&&r.optimizer_state_dict&&await this._loadOptimizerState(s,r.optimizer_state_dict),{epoch:r.epoch,loss:r.loss,model_state:r.state_dict,optimizer_state:r.optimizer_state_dict,metadata:r.metadata}}async _extractStateDict(e){const t={};if(!e||"function"!=typeof e.parameters)throw new Error("Invalid model: must have parameters() method");const s=e.parameters();if(e._parameters)for(const[s,r]of Object.entries(e._parameters))t[s]=await this._serializeTensor(r);if(e._modules)for(const[s,r]of Object.entries(e._modules)){const e=await this._extractStateDict(r);for(const[r,i]of Object.entries(e))t[`${s}.${r}`]=i}if(0===Object.keys(t).length&&s.length>0)for(let e=0;e<s.length;e++){const r=s[e];t[r._name||`param_${e}`]=await this._serializeTensor(r)}return t}async _serializeTensor(e){if(!e)return null;const t={shape:e.shape||[],dtype:e.dtype||"float32",device:e.device||"cpu",requires_grad:e.requires_grad||!1,data:null};if(e.data)if(Array.isArray(e.data))t.data=e.data;else if("Float32Array"===e.data.constructor.name||"Int32Array"===e.data.constructor.name)t.data=Array.from(e.data);else try{const s=await e.cpu();t.data=Array.isArray(s.data)?s.data:Array.from(s.data)}catch(s){r.A.warn("Failed to serialize WebGPU tensor, using fallback",{error:s.message}),t.data=e.data?Array.from(e.data):[]}return t}async _deserializeTensor(e,t="cpu"){if(!e)return null;const s=globalThis.greed;if(!s)throw new Error("GreedJS not available for tensor deserialization");const r=s.torch.tensor(e.data,{dtype:e.dtype,device:t,requires_grad:e.requires_grad});return e.shape&&e.shape.length>1?r.view(e.shape):r}async _loadStateDict(e,t,s={}){const i=!1!==s.strict,o=s.device||"cpu",a={};if(e._parameters&&Object.assign(a,e._parameters),e._modules)for(const[t,s]of Object.entries(e._modules))if(s._parameters)for(const[e,r]of Object.entries(s._parameters))a[`${t}.${e}`]=r;const n=[],c=[],l=[];for(const[e,s]of Object.entries(t))if(e in a){const t=await this._deserializeTensor(s,o);a[e].data&&(a[e].data.set?a[e].data.set(t.data):a[e].data=t.data),n.push(e)}else l.push(e);for(const e of Object.keys(a))n.includes(e)||c.push(e);if(i&&(c.length>0||l.length>0))throw new Error(`State dict mismatch:\nMissing keys: ${c}\nUnexpected keys: ${l}`);return r.A.info("State dict loaded",{loaded:n.length,missing:c.length,unexpected:l.length}),{loadedKeys:n,missingKeys:c,unexpectedKeys:l}}async _extractOptimizerState(e){return e&&e.state_dict?{state:e.state_dict(),param_groups:e.param_groups}:null}async _loadOptimizerState(e,t){e&&t&&e.load_state_dict&&(e.load_state_dict(t.state),t.param_groups&&(e.param_groups=t.param_groups))}_extractMetadata(e){return{model_class:e.constructor.name,total_parameters:e.parameters?e.parameters().length:0,training_mode:e.training||!1,device_type:this._detectPrimaryDevice(e),architecture:this._analyzeArchitecture(e)}}_detectPrimaryDevice(e){if(!e.parameters)return"cpu";const t=e.parameters();return 0===t.length?"cpu":t[0].device||"cpu"}_analyzeArchitecture(e){const t={modules:[],total_layers:0,parameter_count:0};if(e._modules)for(const[s,r]of Object.entries(e._modules))t.modules.push({name:s,type:r.constructor.name,parameters:r.parameters?r.parameters().length:0}),t.total_layers++;return e.parameters&&(t.parameter_count=e.parameters().reduce((e,t)=>e+(t.data&&t.data.length||0),0)),t}_validateSerializedData(e){if(!e.model_state_dict)throw new Error("Invalid serialized data: missing model_state_dict");e.version||r.A.warn("Serialized data missing version information"),e.version&&e.version!==this.version&&r.A.warn("Version mismatch",{expected:this.version,found:e.version})}async _serializeToBinary(e){return JSON.stringify(e)}async _saveToFile(e,t){if("undefined"!=typeof window){const s=new Blob([e],{type:"application/json"}),r=URL.createObjectURL(s),i=document.createElement("a");return i.href=r,i.download=t.split("/").pop()||"model.json",document.body.appendChild(i),i.click(),document.body.removeChild(i),void URL.revokeObjectURL(r)}throw new Error("File saving not supported in current environment - use browser download")}async _loadFromFile(e){if("undefined"!=typeof window){if(!(e.startsWith("http://")||e.startsWith("https://")||e.startsWith("/")))throw new Error("Local file loading in browser requires user file selection. Use createFileInput() method.");try{const t=await fetch(e);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const s=await t.text();return JSON.parse(s)}catch(t){throw new Error(`Failed to fetch model from ${e}: ${t.message}`)}}throw new Error("File loading not supported in current environment")}createFileInput(e){if("undefined"==typeof window)throw new Error("File input only available in browser environment");const t=document.createElement("input");return t.type="file",t.accept=".json,.greed",t.style.display="none",t.addEventListener("change",async t=>{const s=t.target.files[0];if(s)try{const t=await s.text(),r=JSON.parse(t);e(null,r)}catch(t){e(t,null)}}),t}async cleanup(){this.memoryManager&&await this.memoryManager.cleanup()}}}}]);